### This project is a Spring Boot application aiming to uses some of Spring-Cloud functionalities and learning/utilizing tools mentioned below.

- Docker
- Spring Boot 2.4.x+ & Spring Cloud 2020.x+
- Service Registry using Eureka Naming Server
- Load Balancing with Spring Cloud LoadBalancer (replacing Ribbon)
- API Gateway with Spring Cloud Gateway (instead of Zuul)
- Circuit Breaker with Resilience4j (instead of Hystrix)
- Distributed Tracing with Zipkin

Microservices with Spring Cloud
- Step 01 - Setting up Limits Microservice
- Step 02 - Creating a hard coded limits service
- Step 03 - Enhance limits service to pick up configuration from application properties
- Step 04 - Setting up Spring Cloud Config Server
- Step 05 - Installing Git and Creating Local Git Repository
- Step 06 - Connect Spring Cloud Config Server to Local Git Repository
- Step 07 - Connect Limits Service to Spring Cloud Config Server
- Step 08 - Configuring Profiles for Limits Service
- Step 09 - Introduction to Currency Conversion and Currency Exchange Microservices
- Step 10 - Setting up Currency Exchange Microservice
- Step 11 - Create a simple hard coded currency exchange service
- Step 12 - Setting up Dynamic Port in the Response
- Step 13 - Configure JPA and Initialized Data
- Step 14 - Create a JPA Repository
- Step 15 - Setting up Currency Conversion Microservice
- Step 16 - Creating a service for currency conversion
- Step 17 - Invoking Currency Exchange Microservice from Currency Conversion Microservice
- Step 18 - Using Feign REST Client for Service Invocation
- Step 19 - Understand Naming Server and Setting up Eureka Naming Server
- Step 20 - Connect Currency Conversion Microservice & Currency Exchange Microservice to Eureka
- Step 21 - Load Balancing with Eureka, Feign & Spring Cloud LoadBalancer
- Step 22 - Setting up Spring Cloud API Gateway
- Step 23 - Enabling Discovery Locator with Eureka for Spring Cloud Gateway
- Step 24 - Exploring Routes with Spring Cloud Gateway
- Step 25 - Implementing Spring Cloud Gateway Logging Filter
- Step 26 - Getting started with Circuit Breaker - Resilience4j
- Step 27 - Playing with Resilience4j - Retry and Fallback Methods
- Step 28 - Playing with Circuit Breaker Features of Resilience4j
- Step 29 - Exploring Rate Limiting and BulkHead Features of Resilience4j


## Docker with Microservices using Spring Boot and Spring Cloud
- Step 00 - Match made in Heaven - Docker and Microservices
- Step 01 - Installing Docker - Docker
- Step 02 - Your First Docker Use case - Deploy a Spring Boot Application
- Step 03 - Important Docker Concepts - Registry, Repository, Tag, Image and Container
- Step 04 - Playing with Docker Images and Containers
- Step 05 - Understanding Docker Architecture - Docker Client, Docker Engine
- Step 06 - Why is Docker Popular
- Step 07 - Playing with Docker Images
- Step 08 - Playing with Docker Containers
- Step 09 - Playing with Docker Commands - stats, system
- Step 10 - Introduction to Distributed Tracing
- Step 11 - Launching Zipkin Container using Docker
- Step 12 - Connecting Currency Exchange Microservice with Zipkin
- Step 13 - Connecting Currency Conversion Microservice and API Gateway with Zipkin
- Step 14 - Getting Setup with Microservices for Creating Container Images
- Step 15 - Creating Container Image for Currency Exchange Microservice
- Step 16 - Getting Started with Docker Compose - Currency Exchange Microservice
- Step 17 - Running Eureka Naming Server with Docker Compose
- Step 18 - Running Currency Conversion Microservice with Docker Compose
- Step 19 - Running Spring Cloud API Gateway with Docker Compose
- Step 20 - Running Zipkin with Docker Compose
